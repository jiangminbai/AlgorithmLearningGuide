/**
 * 递归
 * 递推公式的定义：在数列{a(n)}中，任意项a(n)与前一项a(n-1)或前几项的关系，被称为递推公式
 */

/**
 * 场景
 * 阶乘
 * 数学公式: f(n) = n * f(n-1);f(1) = 1
 * @param {number} n 阶乘的最大数
 * @returns {number} 阶乘结果
 */
function factorial(n) {
  if (n <= 1) return n // 基线条件
  else return n * factorial(n - 1) // 递归条件
}

var r = factorial(5)
console.log(`5的阶乘: ${r}`)

var r = factorial(100)
console.log(`100的阶乘: ${r}`)

var r = factorial(10000)
console.log(`10000的阶乘: ${r}`)

/**
 * 递归函数使用函数调用栈(call stack)，每个调用一个函数就会为该函数及其相关变量分配一块内存并压入栈中，当调用完成，会将其弹出并删除
 * 递归的方式很简便，但是每个函数都会占用内存，如果占用内存过多会造成内存溢出
 */

/**
 * 求解递归式
 * 总的来说两种方法：
 * 1.归纳证明：先猜结果再证明
 * 2.演绎推理：通过公理去推理
 * 具体方法：
 * 1.代入法->属于归纳证明法(要猜对比较难)
 * 2.递归树方法->通过递归树去算(计算过程复杂)
 * 3.主定理->给出定理，用定理直接算(非常快速)
 */

/**
 * 主定理：当a>=1;b>1是常数;f(n)是一个函数,T(n)是定义在非负整数上的递归式：T(n) = aT(n/b) + f(n),那么T(n)有如下渐进界：
 * (1).若对某个常数u>0有f(n)=O(n^log b(a-u)),那么T(n)=Θ(n^logb(a))
 * (2).若f(n)=Θ(n^log b(a)),则T(n)=Θ(nlogb(a)lgn)
 * (3).若对某个常数u>0有f(n)=Ω(n^logb(a+u)),且对某个常数c<1和所有足够大的n有af(n/b)<=cf(n),则T(n)=Θ(f(n))
 * 理解:f(n)与n^logb(a)做比较，f(n)小就(1);相当大就(2);f(n)大就(3)；这里的大于必须是多项式的大于f(n)=g(n)*n^ε。
 */

/**
 * 例子：
 * 1.T(n) = 9T(n/3) + n
 * a=9;b=3;f(n)=n; n^log3~9=n^2>n=> O(n^2)
 * 2.T(n) = T(2n/3) + 1
 * a=1;b=3/2;f(n)=1;n^log3/2~1=n^0=1 => O(lgn)
 * 3.T(n) = 3T(n/4) + nlgn
 * a=3;b=4;f(n)=nlgn;n^log4~3 n^log4~(3+u)
 */